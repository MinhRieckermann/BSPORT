import { Component, ChangeDetectionStrategy, ElementRef, Renderer2, Attribute, Directive, Input, HostBinding, EventEmitter, ViewEncapsulation, ChangeDetectorRef, ViewChild, Output, ContentChild, ContentChildren, Injectable, ɵɵdefineInjectable, Optional, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = [[["", "pIcon", ""], ["", "p-icon", ""], ["", "pSvg", ""], ["", "p-svg", ""], ["", "pImage", ""], ["", "p-image", ""]], "*"];
const _c1 = ["[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]", "*"];
const _c2 = ["will-change", ""];
const _c3 = ["inputElem"];
const _c4 = ["stateElem"];
function NgxPrettyCheckboxComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3, 4);
    ɵngcc0.ɵɵprojection(2, 1);
    ɵngcc0.ɵɵelementStart(3, "label");
    ɵngcc0.ɵɵprojection(4, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
const _c5 = [[["ngx-p-indeterminate"], ["p-indeterminate"], ["ngx-p-hover"], ["p-hover"], ["ngx-p-toggle"], ["p-toggle"]], [["", "pIcon", ""], ["", "p-icon", ""], ["", "pSvg", ""], ["", "p-svg", ""], ["", "pImage", ""], ["", "p-image", ""]], "*"];
const _c6 = ["ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle", "[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]", "*"];
const _c7 = function (a0) { return [a0]; };
function NgxPrettyCheckboxWillChangeComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementStart(2, "label");
    ɵngcc0.ɵɵprojection(3, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(1, _c7, ctx_r1.color ? ctx_r1._prefix + ctx_r1.color + (ctx_r1.outline ? ctx_r1._outlinePrefix : "") : ""));
} }
function NgxPrettyRadioComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3, 4);
    ɵngcc0.ɵɵprojection(2, 1);
    ɵngcc0.ɵɵelementStart(3, "label");
    ɵngcc0.ɵɵprojection(4, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
const _c8 = [[["ngx-p-hover"], ["p-hover"], ["ngx-p-toggle"], ["p-toggle"]], [["", "pIcon", ""], ["", "p-icon", ""], ["", "pSvg", ""], ["", "p-svg", ""], ["", "pImage", ""], ["", "p-image", ""]], "*"];
const _c9 = ["ngx-p-hover, p-hover, ngx-p-toggle, p-toggle", "[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]", "*"];
function NgxPrettyRadioWillChangeComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementStart(2, "label");
    ɵngcc0.ɵɵprojection(3, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(1, _c7, ctx_r1.color ? ctx_r1._prefix + ctx_r1.color + (ctx_r1.outline ? ctx_r1._outlinePrefix : "") : ""));
} }
const DEFAULT_PRETTY_CLASS_NAME = 'pretty';
/** @type {?} */
const DEFAULT_PREFIX = 'p-';
/** @type {?} */
const DEFAULT_OUTLINE_PREFIX = '-o';
/** @type {?} */
const GROUP_NAME = 'p-radio';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const PrettyCheckBoxToggleType = {
    On: 'on',
    Off: 'off',
};
/** @enum {string} */
const PrettyCheckboxStroke = {
    // Accept Null
    Fill: 'fill',
    Thick: 'thick',
    Slim: 'slim' // Switch
    ,
};
/** @enum {string} */
const PrettyCheckboxShape = {
    // Accept Null
    Curve: 'curve',
    Round: 'round',
};
/** @enum {string} */
const PrettyCheckboxColor = {
    Primary: 'primary',
    Success: 'success',
    Info: 'info',
    Warning: 'warning',
    Danger: 'danger',
};
/** @enum {string} */
const PrettyCheckboxAnimation = {
    Smooth: 'smooth',
    Jelly: 'jelly',
    Tada: 'tada',
    Rotate: 'rotate',
    Pulse: 'pulse',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyHoverComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?=} _outline
     * @param {?=} _color
     */
    constructor(el, renderer, _outline = false, _color) {
        this.el = el;
        this.renderer = renderer;
        this._outline = _outline;
        this._color = _color;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this._color) {
            this.renderer.addClass(this.el.nativeElement, `${DEFAULT_PREFIX}${this._color}${this._outline ? DEFAULT_OUTLINE_PREFIX : ''}`);
        }
    }
}
NgxPrettyHoverComponent.ɵfac = function NgxPrettyHoverComponent_Factory(t) { return new (t || NgxPrettyHoverComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinjectAttribute('outline'), ɵngcc0.ɵɵinjectAttribute('color')); };
NgxPrettyHoverComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyHoverComponent, selectors: [["ngx-p-hover", 3, "will-change", ""], ["p-hover", 3, "will-change", ""]], hostAttrs: [1, "state", "p-is-hover"], ngContentSelectors: _c1, decls: 3, vars: 0, template: function NgxPrettyHoverComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
NgxPrettyHoverComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyHoverComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-p-hover:not([will-change]), p-hover:not([will-change])',
                template: `
    <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
    <label><ng-content></ng-content></label>
  `,
                host: {
                    class: `state ${DEFAULT_PREFIX}is-hover`
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['outline']
            }] }, { type: PrettyCheckboxColor, decorators: [{
                type: Attribute,
                args: ['color']
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyIconDirective {
    /**
     * @param {?} elemRef
     */
    constructor(elemRef) {
        this.elemRef = elemRef;
        this.elemRef.nativeElement.classList.add('icon');
    }
}
NgxPrettyIconDirective.ɵfac = function NgxPrettyIconDirective_Factory(t) { return new (t || NgxPrettyIconDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxPrettyIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxPrettyIconDirective, selectors: [["", "pIcon", ""], ["", "p-icon", ""]] });
/** @nocollapse */
NgxPrettyIconDirective.ctorParameters = () => [
    { type: ElementRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyIconDirective, [{
        type: Directive,
        args: [{
                selector: '[pIcon], [p-icon]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyImageDirective {
    /**
     * @param {?} elemRef
     */
    constructor(elemRef) {
        this.elemRef = elemRef;
        console.log('TCL: NgxPrettyImageDirective -> constructor -> elemRef', elemRef);
        this.elemRef.nativeElement.classList.add('image');
    }
}
NgxPrettyImageDirective.ɵfac = function NgxPrettyImageDirective_Factory(t) { return new (t || NgxPrettyImageDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxPrettyImageDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxPrettyImageDirective, selectors: [["", "pImage", ""], ["", "p-image", ""]] });
/** @nocollapse */
NgxPrettyImageDirective.ctorParameters = () => [
    { type: ElementRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyImageDirective, [{
        type: Directive,
        args: [{
                selector: '[pImage], [p-image]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyIndeterminateComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?=} _outline
     * @param {?=} _color
     */
    constructor(el, renderer, _outline = false, _color) {
        this.el = el;
        this.renderer = renderer;
        this._outline = _outline;
        this._color = _color;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this._color) {
            this.renderer.addClass(this.el.nativeElement, `${DEFAULT_PREFIX}${this._color}${this._outline ? DEFAULT_OUTLINE_PREFIX : ''}`);
        }
    }
}
NgxPrettyIndeterminateComponent.ɵfac = function NgxPrettyIndeterminateComponent_Factory(t) { return new (t || NgxPrettyIndeterminateComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinjectAttribute('outline'), ɵngcc0.ɵɵinjectAttribute('color')); };
NgxPrettyIndeterminateComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyIndeterminateComponent, selectors: [["ngx-p-indeterminate", 3, "will-change", ""], ["p-indeterminate", 3, "will-change", ""]], hostAttrs: [1, "state", "p-is-indeterminate"], ngContentSelectors: _c1, decls: 3, vars: 0, template: function NgxPrettyIndeterminateComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
NgxPrettyIndeterminateComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyIndeterminateComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-p-indeterminate:not([will-change]), p-indeterminate:not([will-change])',
                template: `
    <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
    <label><ng-content></ng-content></label>
  `,
                host: {
                    class: `state ${DEFAULT_PREFIX}is-indeterminate`
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['outline']
            }] }, { type: PrettyCheckboxColor, decorators: [{
                type: Attribute,
                args: ['color']
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettySvgDirective {
    /**
     * @param {?} elemRef
     */
    constructor(elemRef) {
        this.elemRef = elemRef;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.elemRef.nativeElement.classList.add('svg');
    }
}
NgxPrettySvgDirective.ɵfac = function NgxPrettySvgDirective_Factory(t) { return new (t || NgxPrettySvgDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxPrettySvgDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxPrettySvgDirective, selectors: [["", "pSvg", ""], ["", "p-svg", ""]] });
/** @nocollapse */
NgxPrettySvgDirective.ctorParameters = () => [
    { type: ElementRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettySvgDirective, [{
        type: Directive,
        args: [{
                selector: '[pSvg], [p-svg]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyToggleComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?=} _outline
     * @param {?=} _color
     * @param {?=} _type
     */
    constructor(el, renderer, _outline = false, _color, _type) {
        this.el = el;
        this.renderer = renderer;
        this._outline = _outline;
        this._color = _color;
        this._type = _type;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this._color) {
            this.renderer.addClass(this.el.nativeElement, `${DEFAULT_PREFIX}${this._color}${this._outline ? DEFAULT_OUTLINE_PREFIX : ''}`);
        }
        this.renderer.addClass(this.el.nativeElement, `${DEFAULT_PREFIX}${this._type}`);
    }
}
NgxPrettyToggleComponent.ɵfac = function NgxPrettyToggleComponent_Factory(t) { return new (t || NgxPrettyToggleComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinjectAttribute('outline'), ɵngcc0.ɵɵinjectAttribute('color'), ɵngcc0.ɵɵinjectAttribute('type')); };
NgxPrettyToggleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyToggleComponent, selectors: [["ngx-p-toggle", 3, "will-change", ""], ["p-toggle", 3, "will-change", ""]], hostAttrs: [1, "state"], ngContentSelectors: _c1, decls: 3, vars: 0, template: function NgxPrettyToggleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
NgxPrettyToggleComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] },
    { type: PrettyCheckBoxToggleType, decorators: [{ type: Attribute, args: ['type',] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyToggleComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-p-toggle:not([will-change]), p-toggle:not([will-change])',
                template: `
    <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
    <label><ng-content></ng-content></label>
  `,
                host: {
                    class: 'state'
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['outline']
            }] }, { type: PrettyCheckboxColor, decorators: [{
                type: Attribute,
                args: ['color']
            }] }, { type: PrettyCheckBoxToggleType, decorators: [{
                type: Attribute,
                args: ['type']
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} color
 * @param {?=} outline
 * @return {?}
 */
function getColorClassName(color, outline) {
    if (!color) {
        return null;
    }
    return DEFAULT_PREFIX + color + (outline ? DEFAULT_OUTLINE_PREFIX : '');
}
/**
 * @param {?=} str
 * @return {?}
 */
function strToBoolean(str) {
    if (typeof str === 'boolean') {
        return str;
    }
    /** @type {?} */
    const regex = /^\s*(true|1|on|enable)\s*$/i;
    return regex.test(str);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyHoverWillChangeComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.outline = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.color || changes.outline) {
            /** @type {?} */
            const oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
            /** @type {?} */
            const newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
            this.renderer.removeClass(this.el.nativeElement, oldClass);
            this.renderer.addClass(this.el.nativeElement, newClass);
        }
    }
}
NgxPrettyHoverWillChangeComponent.ɵfac = function NgxPrettyHoverWillChangeComponent_Factory(t) { return new (t || NgxPrettyHoverWillChangeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NgxPrettyHoverWillChangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyHoverWillChangeComponent, selectors: [["ngx-p-hover", "will-change", ""], ["p-hover", "will-change", ""]], hostAttrs: [1, "state", "p-is-hover"], inputs: { outline: "outline", color: "color" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c2, ngContentSelectors: _c1, decls: 3, vars: 0, template: function NgxPrettyHoverWillChangeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
NgxPrettyHoverWillChangeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NgxPrettyHoverWillChangeComponent.propDecorators = {
    color: [{ type: Input }],
    outline: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyHoverWillChangeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-p-hover[will-change], p-hover[will-change]',
                template: `
    <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
    <label><ng-content></ng-content></label>
  `,
                host: {
                    class: `state ${DEFAULT_PREFIX}is-hover`
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { outline: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyIndeterminateWillChangeComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.outline = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.color || changes.outline) {
            /** @type {?} */
            const oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
            /** @type {?} */
            const newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
            this.renderer.removeClass(this.el.nativeElement, oldClass);
            this.renderer.addClass(this.el.nativeElement, newClass);
        }
    }
}
NgxPrettyIndeterminateWillChangeComponent.ɵfac = function NgxPrettyIndeterminateWillChangeComponent_Factory(t) { return new (t || NgxPrettyIndeterminateWillChangeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NgxPrettyIndeterminateWillChangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyIndeterminateWillChangeComponent, selectors: [["ngx-p-indeterminate", "will-change", ""], ["p-indeterminate", "will-change", ""]], hostAttrs: [1, "state", "p-is-indeterminate"], inputs: { outline: "outline", color: "color" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c2, ngContentSelectors: _c1, decls: 3, vars: 0, template: function NgxPrettyIndeterminateWillChangeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
NgxPrettyIndeterminateWillChangeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NgxPrettyIndeterminateWillChangeComponent.propDecorators = {
    color: [{ type: Input }],
    outline: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyIndeterminateWillChangeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-p-indeterminate[will-change], p-indeterminate[will-change]',
                template: `
    <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
    <label><ng-content></ng-content></label>
  `,
                host: {
                    class: `state ${DEFAULT_PREFIX}is-indeterminate`
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { outline: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyToggleWillChangeComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.outline = false;
    }
    /**
     * @return {?}
     */
    get isToggleOn() { return this.type === PrettyCheckBoxToggleType.On; }
    /**
     * @return {?}
     */
    get isToggleOff() { return this.type === PrettyCheckBoxToggleType.Off; }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.color || changes.outline) {
            /** @type {?} */
            const oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
            /** @type {?} */
            const newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
            this.renderer.removeClass(this.el.nativeElement, oldClass);
            this.renderer.addClass(this.el.nativeElement, newClass);
        }
    }
}
NgxPrettyToggleWillChangeComponent.ɵfac = function NgxPrettyToggleWillChangeComponent_Factory(t) { return new (t || NgxPrettyToggleWillChangeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NgxPrettyToggleWillChangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyToggleWillChangeComponent, selectors: [["ngx-p-toggle", "will-change", ""], ["p-toggle", "will-change", ""]], hostAttrs: [1, "state"], hostVars: 4, hostBindings: function NgxPrettyToggleWillChangeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("p-on", ctx.isToggleOn)("p-off", ctx.isToggleOff);
    } }, inputs: { outline: "outline", type: "type", color: "color" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c2, ngContentSelectors: _c1, decls: 3, vars: 0, template: function NgxPrettyToggleWillChangeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
NgxPrettyToggleWillChangeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NgxPrettyToggleWillChangeComponent.propDecorators = {
    type: [{ type: Input }],
    isToggleOn: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}on`,] }],
    isToggleOff: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}off`,] }],
    color: [{ type: Input }],
    outline: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyToggleWillChangeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-p-toggle[will-change], p-toggle[will-change]',
                template: `
    <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
    <label><ng-content></ng-content></label>
  `,
                host: {
                    class: 'state'
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { outline: [{
            type: Input
        }], isToggleOn: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}on`]
        }], isToggleOff: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}off`]
        }], type: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:use-host-property-decorator
class NgxPrettyCheckboxComponent {
    /**
     * @param {?} renderer
     * @param {?} el
     * @param {?} cd
     * @param {?} _stroke
     * @param {?} _shape
     * @param {?} _animation
     * @param {?=} _isSwitch
     * @param {?=} _bigger
     * @param {?=} _enableFocus
     * @param {?=} _plain
     * @param {?=} _outline
     * @param {?=} _color
     */
    constructor(renderer, el, cd, _stroke, _shape, _animation, _isSwitch = false, _bigger = false, _enableFocus = false, _plain = false, _outline = false, _color) {
        this.renderer = renderer;
        this.el = el;
        this.cd = cd;
        this._stroke = _stroke;
        this._shape = _shape;
        this._animation = _animation;
        this._isSwitch = _isSwitch;
        this._bigger = _bigger;
        this._enableFocus = _enableFocus;
        this._plain = _plain;
        this._outline = _outline;
        this._color = _color;
        this._prefix = DEFAULT_PREFIX;
        this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
        this.checked = false;
        this.disabled = false;
        this.lock = false;
        this.change = new EventEmitter();
        this._isSwitch = strToBoolean(this._isSwitch);
        this._bigger = strToBoolean(this._bigger);
        this._enableFocus = strToBoolean(this._enableFocus);
        this._plain = strToBoolean(this._plain);
        this._outline = strToBoolean(this._outline);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const el = this.el.nativeElement;
        if (this._isSwitch) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}switch`);
        }
        if (this._bigger) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}bigger`);
        }
        if (this._enableFocus) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}has-focus`);
        }
        if (this._plain) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}plain`);
        }
        if (this._stroke) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}${this._stroke}`);
        }
        if (this._shape) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}${this._shape}`);
        }
        if (this._animation) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}${this._animation}`);
        }
        if (this._iconDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}icon`);
        }
        if (this._svgDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}svg`);
        }
        if (this._imgDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}image`);
        }
        if (this._hoverDir || this._hoverWillChangeDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}has-hover`);
        }
        if (this._indeterminateDir || this._indeterminateWillChangeDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}has-indeterminate`);
        }
        if (this._isToggle) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}toggle`);
        }
        if (!this._isSwitch && !this._iconDir && !this._svgDir && !this._imgDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}default`);
        }
        // STATE ELEM
        if (this._color && !this._isToggle) {
            this.renderer.addClass(this._stateElem.nativeElement, `${DEFAULT_PREFIX}${this._color}${this._outline ? DEFAULT_OUTLINE_PREFIX : ''}`);
        }
    }
    // ---------- PRIVATE METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    _onChange(event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.checked = checked;
        this.change.emit({ value, checked, event });
    }
    /**
     * @return {?}
     */
    get _isToggle() { return this._toggleComps.length === 2 || this._toggleWillChangeComps.length === 2; }
    // ---------- PUBLIC METHODS ---------
    /**
     * @param {?=} value
     * @return {?}
     */
    setIndeterminate(value = true) {
        this._inputElem.nativeElement.indeterminate = value;
    }
    /**
     * @param {?} check
     * @return {?}
     */
    forceCheck(check) {
        this.checked = check;
        this.cd.markForCheck();
    }
}
NgxPrettyCheckboxComponent.ɵfac = function NgxPrettyCheckboxComponent_Factory(t) { return new (t || NgxPrettyCheckboxComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵinjectAttribute('stroke'), ɵngcc0.ɵɵinjectAttribute('shape'), ɵngcc0.ɵɵinjectAttribute('animation'), ɵngcc0.ɵɵinjectAttribute('isSwitch'), ɵngcc0.ɵɵinjectAttribute('bigger'), ɵngcc0.ɵɵinjectAttribute('enableFocus'), ɵngcc0.ɵɵinjectAttribute('plain'), ɵngcc0.ɵɵinjectAttribute('outline'), ɵngcc0.ɵɵinjectAttribute('color')); };
NgxPrettyCheckboxComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyCheckboxComponent, selectors: [["ngx-pretty-checkbox", 3, "will-change", ""], ["p-checkbox", 3, "will-change", ""]], contentQueries: function NgxPrettyCheckboxComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIconDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettySvgDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyImageDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverWillChangeComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIndeterminateComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIndeterminateWillChangeComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleComponent, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleWillChangeComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._iconDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._svgDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._imgDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverWillChangeDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._indeterminateDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._indeterminateWillChangeDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleComps = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleWillChangeComps = _t);
    } }, viewQuery: function NgxPrettyCheckboxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c3, true);
        ɵngcc0.ɵɵviewQuery(_c4, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._stateElem = _t.first);
    } }, hostAttrs: [1, "pretty"], hostVars: 2, hostBindings: function NgxPrettyCheckboxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("p-locked", ctx.lock);
    } }, inputs: { checked: "checked", disabled: "disabled", lock: "lock", value: "value" }, outputs: { change: "change" }, exportAs: ["ngxPrettyCheckbox"], ngContentSelectors: _c6, decls: 4, vars: 4, consts: [["type", "checkbox", 3, "value", "checked", "disabled", "change"], ["inputElem", ""], ["class", "state", 4, "ngIf"], [1, "state"], ["stateElem", ""]], template: function NgxPrettyCheckboxComponent_Template(rf, ctx) { if (rf & 1) {
        const _r3 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵprojectionDef(_c5);
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function NgxPrettyCheckboxComponent_Template_input_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const _r0 = ɵngcc0.ɵɵreference(1); return ctx._onChange($event, _r0.checked, _r0.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NgxPrettyCheckboxComponent_div_2_Template, 5, 0, "div", 2);
        ɵngcc0.ɵɵprojection(3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx._isToggle);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/** @nocollapse */
NgxPrettyCheckboxComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: PrettyCheckboxStroke, decorators: [{ type: Attribute, args: ['stroke',] }] },
    { type: PrettyCheckboxShape, decorators: [{ type: Attribute, args: ['shape',] }] },
    { type: PrettyCheckboxAnimation, decorators: [{ type: Attribute, args: ['animation',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['isSwitch',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['bigger',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['enableFocus',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['plain',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] }
];
NgxPrettyCheckboxComponent.propDecorators = {
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    lock: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}locked`,] }, { type: Input }],
    _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
    _stateElem: [{ type: ViewChild, args: ['stateElem', { static: false },] }],
    change: [{ type: Output }],
    _iconDir: [{ type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
    _svgDir: [{ type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
    _imgDir: [{ type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
    _hoverDir: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
    _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
    _indeterminateDir: [{ type: ContentChild, args: [NgxPrettyIndeterminateComponent, { static: false },] }],
    _indeterminateWillChangeDir: [{ type: ContentChild, args: [NgxPrettyIndeterminateWillChangeComponent, { static: false },] }],
    _toggleComps: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
    _toggleWillChangeComps: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyCheckboxComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-pretty-checkbox:not([will-change]), p-checkbox:not([will-change])',
                template: `
    <input
      #inputElem
      type="checkbox"
      [value]="value"
      [checked]="checked"
      [disabled]="disabled"
      (change)="_onChange($event, inputElem.checked, inputElem.value)"/>

    <div #stateElem *ngIf="!_isToggle" class="state">

      <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
      <label><ng-content></ng-content></label>

    </div>

    <ng-content select="ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle"></ng-content>
  `,
                // changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': DEFAULT_PRETTY_CLASS_NAME
                },
                exportAs: 'ngxPrettyCheckbox'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: PrettyCheckboxStroke, decorators: [{
                type: Attribute,
                args: ['stroke']
            }] }, { type: PrettyCheckboxShape, decorators: [{
                type: Attribute,
                args: ['shape']
            }] }, { type: PrettyCheckboxAnimation, decorators: [{
                type: Attribute,
                args: ['animation']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['isSwitch']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['bigger']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['enableFocus']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['plain']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['outline']
            }] }, { type: PrettyCheckboxColor, decorators: [{
                type: Attribute,
                args: ['color']
            }] }]; }, { checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], lock: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}locked`]
        }, {
            type: Input
        }], change: [{
            type: Output
        }], value: [{
            type: Input
        }], _inputElem: [{
            type: ViewChild,
            args: ['inputElem', { static: true }]
        }], _stateElem: [{
            type: ViewChild,
            args: ['stateElem', { static: false }]
        }], _iconDir: [{
            type: ContentChild,
            args: [NgxPrettyIconDirective, { static: false }]
        }], _svgDir: [{
            type: ContentChild,
            args: [NgxPrettySvgDirective, { static: false }]
        }], _imgDir: [{
            type: ContentChild,
            args: [NgxPrettyImageDirective, { static: false }]
        }], _hoverDir: [{
            type: ContentChild,
            args: [NgxPrettyHoverComponent, { static: false }]
        }], _hoverWillChangeDir: [{
            type: ContentChild,
            args: [NgxPrettyHoverWillChangeComponent, { static: false }]
        }], _indeterminateDir: [{
            type: ContentChild,
            args: [NgxPrettyIndeterminateComponent, { static: false }]
        }], _indeterminateWillChangeDir: [{
            type: ContentChild,
            args: [NgxPrettyIndeterminateWillChangeComponent, { static: false }]
        }], _toggleComps: [{
            type: ContentChildren,
            args: [NgxPrettyToggleComponent]
        }], _toggleWillChangeComps: [{
            type: ContentChildren,
            args: [NgxPrettyToggleWillChangeComponent]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:use-host-property-decorator
class NgxPrettyCheckboxWillChangeComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        this.cd = cd;
        this._prefix = DEFAULT_PREFIX;
        this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
        this.change = new EventEmitter();
        this.outline = false; // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        this.checked = false;
        this.disabled = false;
        // ----- INPUTS AND BINDING ------
        // SWITCH
        this.isSwitch = false;
        //  LOCK
        this.lock = false;
        //  BIGGER
        this.bigger = false;
        //  FOCUS
        this.enableFocus = false;
        //  PLAIN
        this.plain = false; // To remove the border ( when checkbox is checked ) 
    }
    // To remove the border ( when checkbox is checked ) 
    // ---------- STROKE ----------
    // Fill
    /**
     * @return {?}
     */
    get _isFill() { return this.stroke === PrettyCheckboxStroke.Fill; }
    // Slim
    /**
     * @return {?}
     */
    get _isSlim() { return this.stroke === PrettyCheckboxStroke.Slim; }
    // Thick
    /**
     * @return {?}
     */
    get _isThick() { return this.stroke === PrettyCheckboxStroke.Thick; }
    // ---------- SHAPE ----------
    // Curve
    /**
     * @return {?}
     */
    get _isCurve() { return this.shape === PrettyCheckboxShape.Curve; }
    // Round
    /**
     * @return {?}
     */
    get _isRound() { return this.shape === PrettyCheckboxShape.Round; }
    // ---------- ANIMATION ----------
    // Smooth
    /**
     * @return {?}
     */
    get _isSmooth() { return this.animation === PrettyCheckboxAnimation.Smooth; }
    // Jelly
    /**
     * @return {?}
     */
    get _isJelly() { return this.animation === PrettyCheckboxAnimation.Jelly; }
    // Tada
    /**
     * @return {?}
     */
    get _isTada() { return this.animation === PrettyCheckboxAnimation.Tada; }
    // Rotate
    /**
     * @return {?}
     */
    get _isRotate() { return this.animation === PrettyCheckboxAnimation.Rotate; }
    // Pulse
    /**
     * @return {?}
     */
    get _isPulse() { return this.animation === PrettyCheckboxAnimation.Pulse; }
    /**
     * @return {?}
     */
    get _isToggle() { return this._toggleComp.length === 2 || this._toggleWillChangeComp.length === 2; }
    // DEFAULT
    /**
     * @return {?}
     */
    get _isDefault() { return !this.isSwitch && !this._iconElem && !this._svgElem && !this._imageElem; }
    /**
     * @return {?}
     */
    get _isHover() { return this._hoverComp || this._hoverWillChangeDir; }
    /**
     * @return {?}
     */
    get _isIndeterminate() { return this._indeterminateComp || this._indeterminateWillChangeComp; }
    // ---------- PRIVATE METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    _onChange(event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.checked = checked;
        this.change.emit({ value, checked, event });
    }
    // ---------- PUBLIC METHODS ---------
    /**
     * @param {?=} value
     * @return {?}
     */
    setIndeterminate(value = true) {
        this._inputElem.nativeElement.indeterminate = value;
    }
    /**
     * @param {?} check
     * @return {?}
     */
    forceCheck(check) {
        this.checked = check;
        this.cd.markForCheck();
    }
}
NgxPrettyCheckboxWillChangeComponent.ɵfac = function NgxPrettyCheckboxWillChangeComponent_Factory(t) { return new (t || NgxPrettyCheckboxWillChangeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NgxPrettyCheckboxWillChangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyCheckboxWillChangeComponent, selectors: [["ngx-pretty-checkbox", "will-change", ""], ["p-checkbox", "will-change", ""]], contentQueries: function NgxPrettyCheckboxWillChangeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIconDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettySvgDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyImageDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverWillChangeComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIndeterminateComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIndeterminateWillChangeComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleComponent, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleWillChangeComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._iconElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._svgElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._imageElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverWillChangeDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverComp = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._indeterminateComp = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._indeterminateWillChangeComp = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleComp = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleWillChangeComp = _t);
    } }, viewQuery: function NgxPrettyCheckboxWillChangeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c3, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElem = _t.first);
    } }, hostAttrs: [1, "pretty"], hostVars: 44, hostBindings: function NgxPrettyCheckboxWillChangeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("p-switch", ctx.isSwitch)("p-locked", ctx.lock)("p-bigger", ctx.bigger)("p-has-focus", ctx.enableFocus)("p-plain", ctx.plain)("p-fill", ctx._isFill)("p-slim", ctx._isSlim)("p-thick", ctx._isThick)("p-curve", ctx._isCurve)("p-round", ctx._isRound)("p-smooth", ctx._isSmooth)("p-jelly", ctx._isJelly)("p-tada", ctx._isTada)("p-rotate", ctx._isRotate)("p-pulse", ctx._isPulse)("p-toggle", ctx._isToggle)("p-default", ctx._isDefault)("p-has-hover", ctx._isHover)("p-has-indeterminate", ctx._isIndeterminate)("p-icon", ctx._iconElem)("p-svg", ctx._svgElem)("p-image", ctx._imageElem);
    } }, inputs: { outline: "outline", checked: "checked", disabled: "disabled", isSwitch: "isSwitch", lock: "lock", bigger: "bigger", enableFocus: "enableFocus", plain: "plain", stroke: "stroke", shape: "shape", animation: "animation", color: "color", value: "value" }, outputs: { change: "change" }, exportAs: ["ngxPrettyCheckboxWillChange"], attrs: _c2, ngContentSelectors: _c6, decls: 4, vars: 4, consts: [["type", "checkbox", 3, "value", "checked", "disabled", "change"], ["inputElem", ""], ["class", "state", 3, "ngClass", 4, "ngIf"], [1, "state", 3, "ngClass"]], template: function NgxPrettyCheckboxWillChangeComponent_Template(rf, ctx) { if (rf & 1) {
        const _r2 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵprojectionDef(_c5);
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function NgxPrettyCheckboxWillChangeComponent_Template_input_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const _r0 = ɵngcc0.ɵɵreference(1); return ctx._onChange($event, _r0.checked, _r0.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NgxPrettyCheckboxWillChangeComponent_div_2_Template, 4, 3, "div", 2);
        ɵngcc0.ɵɵprojection(3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx._isToggle);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
NgxPrettyCheckboxWillChangeComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NgxPrettyCheckboxWillChangeComponent.propDecorators = {
    _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
    change: [{ type: Output }],
    stroke: [{ type: Input }],
    shape: [{ type: Input }],
    animation: [{ type: Input }],
    color: [{ type: Input }],
    outline: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    isSwitch: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}switch`,] }, { type: Input }],
    lock: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}locked`,] }, { type: Input }],
    bigger: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}bigger`,] }, { type: Input }],
    enableFocus: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}has-focus`,] }, { type: Input }],
    plain: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}plain`,] }, { type: Input }],
    _isFill: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Fill}`,] }],
    _isSlim: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Slim}`,] }],
    _isThick: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Thick}`,] }],
    _isCurve: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxShape.Curve}`,] }],
    _isRound: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxShape.Round}`,] }],
    _isSmooth: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Smooth}`,] }],
    _isJelly: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Jelly}`,] }],
    _isTada: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Tada}`,] }],
    _isRotate: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Rotate}`,] }],
    _isPulse: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Pulse}`,] }],
    _toggleComp: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
    _toggleWillChangeComp: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }],
    _isToggle: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}toggle`,] }],
    _isDefault: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}default`,] }],
    _iconElem: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}icon`,] }, { type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
    _svgElem: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}svg`,] }, { type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
    _imageElem: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}image`,] }, { type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
    _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
    _hoverComp: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
    _isHover: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}has-hover`,] }],
    _indeterminateComp: [{ type: ContentChild, args: [NgxPrettyIndeterminateComponent, { static: false },] }],
    _indeterminateWillChangeComp: [{ type: ContentChild, args: [NgxPrettyIndeterminateWillChangeComponent, { static: false },] }],
    _isIndeterminate: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}has-indeterminate`,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyCheckboxWillChangeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-pretty-checkbox[will-change], p-checkbox[will-change]',
                template: `
    <input
      #inputElem
      type="checkbox"
      [value]="value"
      [checked]="checked"
      [disabled]="disabled"
      (change)="_onChange($event, inputElem.checked, inputElem.value)"/>

    <div *ngIf="!_isToggle" class="state"
        [ngClass]="[ color ? _prefix + color + (outline ? _outlinePrefix : '') : '' ]">

        <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
        <label><ng-content></ng-content></label>
    </div>

    <ng-content select="ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle"></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': DEFAULT_PRETTY_CLASS_NAME
                },
                exportAs: 'ngxPrettyCheckboxWillChange'
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { change: [{
            type: Output
        }], outline: [{
            type: Input
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], isSwitch: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}switch`]
        }, {
            type: Input
        }], lock: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}locked`]
        }, {
            type: Input
        }], bigger: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}bigger`]
        }, {
            type: Input
        }], enableFocus: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}has-focus`]
        }, {
            type: Input
        }], plain: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}plain`]
        }, {
            type: Input
        }], _isFill: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Fill}`]
        }], _isSlim: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Slim}`]
        }], _isThick: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Thick}`]
        }], _isCurve: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxShape.Curve}`]
        }], _isRound: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxShape.Round}`]
        }], _isSmooth: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Smooth}`]
        }], _isJelly: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Jelly}`]
        }], _isTada: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Tada}`]
        }], _isRotate: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Rotate}`]
        }], _isPulse: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Pulse}`]
        }], _isToggle: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}toggle`]
        }], _isDefault: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}default`]
        }], _isHover: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}has-hover`]
        }], _isIndeterminate: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}has-indeterminate`]
        }], _inputElem: [{
            type: ViewChild,
            args: ['inputElem', { static: true }]
        }], stroke: [{
            type: Input
        }], shape: [{
            type: Input
        }], animation: [{
            type: Input
        }], color: [{
            type: Input
        }], value: [{
            type: Input
        }], _toggleComp: [{
            type: ContentChildren,
            args: [NgxPrettyToggleComponent]
        }], _toggleWillChangeComp: [{
            type: ContentChildren,
            args: [NgxPrettyToggleWillChangeComponent]
        }], _iconElem: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}icon`]
        }, {
            type: ContentChild,
            args: [NgxPrettyIconDirective, { static: false }]
        }], _svgElem: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}svg`]
        }, {
            type: ContentChild,
            args: [NgxPrettySvgDirective, { static: false }]
        }], _imageElem: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}image`]
        }, {
            type: ContentChild,
            args: [NgxPrettyImageDirective, { static: false }]
        }], _hoverWillChangeDir: [{
            type: ContentChild,
            args: [NgxPrettyHoverWillChangeComponent, { static: false }]
        }], _hoverComp: [{
            type: ContentChild,
            args: [NgxPrettyHoverComponent, { static: false }]
        }], _indeterminateComp: [{
            type: ContentChild,
            args: [NgxPrettyIndeterminateComponent, { static: false }]
        }], _indeterminateWillChangeComp: [{
            type: ContentChild,
            args: [NgxPrettyIndeterminateWillChangeComponent, { static: false }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyRadioService {
    constructor() { }
}
NgxPrettyRadioService.ɵfac = function NgxPrettyRadioService_Factory(t) { return new (t || NgxPrettyRadioService)(); };
NgxPrettyRadioService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgxPrettyRadioService, factory: NgxPrettyRadioService.ɵfac, providedIn: 'root' });
/** @nocollapse */
NgxPrettyRadioService.ctorParameters = () => [];
/** @nocollapse */ NgxPrettyRadioService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NgxPrettyRadioService_Factory() { return new NgxPrettyRadioService(); }, token: NgxPrettyRadioService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyRadioService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId = 1;
class NgxPrettyRadioGroupDirective {
    constructor() {
        this.name = GROUP_NAME + nextId++;
        this.change = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _emitChange(event) {
        this.change.emit(event);
    }
}
NgxPrettyRadioGroupDirective.ɵfac = function NgxPrettyRadioGroupDirective_Factory(t) { return new (t || NgxPrettyRadioGroupDirective)(); };
NgxPrettyRadioGroupDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxPrettyRadioGroupDirective, selectors: [["ngx-pretty-radio-group"], ["p-radio-group"]], outputs: { change: "change" }, exportAs: ["ngxRadioGroup"], features: [ɵngcc0.ɵɵProvidersFeature([NgxPrettyRadioService])] });
/** @nocollapse */
NgxPrettyRadioGroupDirective.ctorParameters = () => [];
NgxPrettyRadioGroupDirective.propDecorators = {
    change: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyRadioGroupDirective, [{
        type: Directive,
        args: [{
                selector: 'ngx-pretty-radio-group, p-radio-group',
                providers: [NgxPrettyRadioService],
                exportAs: 'ngxRadioGroup'
            }]
    }], function () { return []; }, { change: [{
            type: Output
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:use-host-property-decorator
class NgxPrettyRadioComponent {
    /**
     * @param {?} renderer
     * @param {?} el
     * @param {?} radioGroup
     * @param {?} _stroke
     * @param {?} _shape
     * @param {?} _animation
     * @param {?=} _isSwitch
     * @param {?=} _bigger
     * @param {?=} _enableFocus
     * @param {?=} _plain
     * @param {?=} _outline
     * @param {?=} _color
     * @param {?=} _name
     */
    constructor(renderer, el, radioGroup, _stroke, _shape, _animation, _isSwitch = false, _bigger = false, _enableFocus = false, _plain = false, _outline = false, _color, _name) {
        this.renderer = renderer;
        this.el = el;
        this.radioGroup = radioGroup;
        this._stroke = _stroke;
        this._shape = _shape;
        this._animation = _animation;
        this._isSwitch = _isSwitch;
        this._bigger = _bigger;
        this._enableFocus = _enableFocus;
        this._plain = _plain;
        this._outline = _outline;
        this._color = _color;
        this._name = _name;
        this._prefix = DEFAULT_PREFIX;
        this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
        this.checked = false;
        this.disabled = false;
        this.lock = false;
        this.change = new EventEmitter();
        if (!this._name && this.radioGroup) {
            this._name = this.radioGroup.name;
        }
        this._isSwitch = strToBoolean(this._isSwitch);
        this._bigger = strToBoolean(this._bigger);
        this._enableFocus = strToBoolean(this._enableFocus);
        this._plain = strToBoolean(this._plain);
        this._outline = strToBoolean(this._outline);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const el = this.el.nativeElement;
        if (this._isSwitch) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}switch`);
        }
        if (this._bigger) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}bigger`);
        }
        if (this._enableFocus) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}has-focus`);
        }
        if (this._plain) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}plain`);
        }
        if (this._stroke) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}${this._stroke}`);
        }
        if (this._shape) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}${this._shape}`);
        }
        if (this._animation) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}${this._animation}`);
        }
        if (this._iconDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}icon`);
        }
        if (this._svgDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}svg`);
        }
        if (this._imgDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}image`);
        }
        if (this._hoverDir || this._hoverWillChangeDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}has-hover`);
        }
        if (this._isToggle) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}toggle`);
        }
        if (!this._isSwitch && !this._iconDir && !this._svgDir && !this._imgDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}default`);
        }
        // STATE ELEM
        if (this._color && !this._isToggle) {
            this.renderer.addClass(this._stateElem.nativeElement, `${DEFAULT_PREFIX}${this._color}${this._outline ? DEFAULT_OUTLINE_PREFIX : ''}`);
        }
    }
    // ---------- METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    _onChange(event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.change.emit({ value, checked, event });
        if (this.radioGroup) {
            this.radioGroup._emitChange({ value, checked, event });
        }
    }
    /**
     * @return {?}
     */
    get _isToggle() { return this._toggleComps.length === 2 || this._toggleWillChangeComps.length === 2; }
}
NgxPrettyRadioComponent.ɵfac = function NgxPrettyRadioComponent_Factory(t) { return new (t || NgxPrettyRadioComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NgxPrettyRadioGroupDirective, 8), ɵngcc0.ɵɵinjectAttribute('stroke'), ɵngcc0.ɵɵinjectAttribute('shape'), ɵngcc0.ɵɵinjectAttribute('animation'), ɵngcc0.ɵɵinjectAttribute('isSwitch'), ɵngcc0.ɵɵinjectAttribute('bigger'), ɵngcc0.ɵɵinjectAttribute('enableFocus'), ɵngcc0.ɵɵinjectAttribute('plain'), ɵngcc0.ɵɵinjectAttribute('outline'), ɵngcc0.ɵɵinjectAttribute('color'), ɵngcc0.ɵɵinjectAttribute('name')); };
NgxPrettyRadioComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyRadioComponent, selectors: [["ngx-pretty-radio", 3, "will-change", ""], ["p-radio", 3, "will-change", ""]], contentQueries: function NgxPrettyRadioComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIconDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettySvgDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyImageDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverWillChangeComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleComponent, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleWillChangeComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._iconDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._svgDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._imgDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverWillChangeDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleComps = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleWillChangeComps = _t);
    } }, viewQuery: function NgxPrettyRadioComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c3, true);
        ɵngcc0.ɵɵviewQuery(_c4, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._stateElem = _t.first);
    } }, hostAttrs: [1, "pretty"], hostVars: 2, hostBindings: function NgxPrettyRadioComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("p-locked", ctx.lock);
    } }, inputs: { checked: "checked", disabled: "disabled", lock: "lock", value: "value" }, outputs: { change: "change" }, exportAs: ["ngxPrettyRadio"], ngContentSelectors: _c9, decls: 4, vars: 5, consts: [["type", "radio", 3, "name", "value", "checked", "disabled", "change"], ["inputElem", ""], ["class", "state", 4, "ngIf"], [1, "state"], ["stateElem", ""]], template: function NgxPrettyRadioComponent_Template(rf, ctx) { if (rf & 1) {
        const _r3 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵprojectionDef(_c8);
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function NgxPrettyRadioComponent_Template_input_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const _r0 = ɵngcc0.ɵɵreference(1); return ctx._onChange($event, _r0.checked, _r0.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NgxPrettyRadioComponent_div_2_Template, 5, 0, "div", 2);
        ɵngcc0.ɵɵprojection(3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("name", ctx._name)("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx._isToggle);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/** @nocollapse */
NgxPrettyRadioComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgxPrettyRadioGroupDirective, decorators: [{ type: Optional }] },
    { type: PrettyCheckboxStroke, decorators: [{ type: Attribute, args: ['stroke',] }] },
    { type: PrettyCheckboxShape, decorators: [{ type: Attribute, args: ['shape',] }] },
    { type: PrettyCheckboxAnimation, decorators: [{ type: Attribute, args: ['animation',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['isSwitch',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['bigger',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['enableFocus',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['plain',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['name',] }] }
];
NgxPrettyRadioComponent.propDecorators = {
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    lock: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}locked`,] }, { type: Input }],
    _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
    _stateElem: [{ type: ViewChild, args: ['stateElem', { static: false },] }],
    change: [{ type: Output }],
    _iconDir: [{ type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
    _svgDir: [{ type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
    _imgDir: [{ type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
    _hoverDir: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
    _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
    _toggleComps: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
    _toggleWillChangeComps: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyRadioComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-pretty-radio:not([will-change]), p-radio:not([will-change])',
                template: `
    <input
      #inputElem
      type="radio"
      [name]="_name"
      [value]="value"
      [checked]="checked"
      [disabled]="disabled"
      (change)="_onChange($event, inputElem.checked, inputElem.value)"/>

    <div #stateElem *ngIf="!_isToggle" class="state">

      <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
      <label><ng-content></ng-content></label>

    </div>

    <ng-content select="ngx-p-hover, p-hover, ngx-p-toggle, p-toggle"></ng-content>
  `,
                // changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': DEFAULT_PRETTY_CLASS_NAME
                },
                exportAs: 'ngxPrettyRadio'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: NgxPrettyRadioGroupDirective, decorators: [{
                type: Optional
            }] }, { type: PrettyCheckboxStroke, decorators: [{
                type: Attribute,
                args: ['stroke']
            }] }, { type: PrettyCheckboxShape, decorators: [{
                type: Attribute,
                args: ['shape']
            }] }, { type: PrettyCheckboxAnimation, decorators: [{
                type: Attribute,
                args: ['animation']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['isSwitch']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['bigger']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['enableFocus']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['plain']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['outline']
            }] }, { type: PrettyCheckboxColor, decorators: [{
                type: Attribute,
                args: ['color']
            }] }, { type: String, decorators: [{
                type: Attribute,
                args: ['name']
            }] }]; }, { checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], lock: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}locked`]
        }, {
            type: Input
        }], change: [{
            type: Output
        }], value: [{
            type: Input
        }], _inputElem: [{
            type: ViewChild,
            args: ['inputElem', { static: true }]
        }], _stateElem: [{
            type: ViewChild,
            args: ['stateElem', { static: false }]
        }], _iconDir: [{
            type: ContentChild,
            args: [NgxPrettyIconDirective, { static: false }]
        }], _svgDir: [{
            type: ContentChild,
            args: [NgxPrettySvgDirective, { static: false }]
        }], _imgDir: [{
            type: ContentChild,
            args: [NgxPrettyImageDirective, { static: false }]
        }], _hoverDir: [{
            type: ContentChild,
            args: [NgxPrettyHoverComponent, { static: false }]
        }], _hoverWillChangeDir: [{
            type: ContentChild,
            args: [NgxPrettyHoverWillChangeComponent, { static: false }]
        }], _toggleComps: [{
            type: ContentChildren,
            args: [NgxPrettyToggleComponent]
        }], _toggleWillChangeComps: [{
            type: ContentChildren,
            args: [NgxPrettyToggleWillChangeComponent]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:use-host-property-decorator
class NgxPrettyRadioWillChangeComponent {
    /**
     * @param {?} radioGroup
     */
    constructor(radioGroup) {
        this.radioGroup = radioGroup;
        this._prefix = DEFAULT_PREFIX;
        this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
        this.change = new EventEmitter();
        this.outline = false; // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        this.checked = false;
        this.disabled = false;
        // ----- INPUTS AND BINDING ------
        // SWITCH
        this.isSwitch = false;
        //  LOCK
        this.lock = false;
        //  BIGGER
        this.bigger = false;
        //  FOCUS
        this.enableFocus = false;
        //  PLAIN
        this.plain = false; // To remove the border ( when checkbox is checked )
        if (radioGroup) {
            this.radioGroupName = radioGroup.name;
        }
    }
    // To remove the border ( when checkbox is checked )
    // ---------- STROKE ----------
    // Fill
    /**
     * @return {?}
     */
    get _isFill() { return this.stroke === PrettyCheckboxStroke.Fill; }
    // Slim
    /**
     * @return {?}
     */
    get _isSlim() { return this.stroke === PrettyCheckboxStroke.Slim; }
    // Thick
    /**
     * @return {?}
     */
    get _isThick() { return this.stroke === PrettyCheckboxStroke.Thick; }
    // ---------- SHAPE ----------
    // Curve
    /**
     * @return {?}
     */
    get _isCurve() { return this.shape === PrettyCheckboxShape.Curve; }
    // Round
    /**
     * @return {?}
     */
    get _isRound() { return this.shape === PrettyCheckboxShape.Round; }
    // ---------- ANIMATION ----------
    // Smooth
    /**
     * @return {?}
     */
    get _isSmooth() { return this.animation === PrettyCheckboxAnimation.Smooth; }
    // Jelly
    /**
     * @return {?}
     */
    get _isJelly() { return this.animation === PrettyCheckboxAnimation.Jelly; }
    // Tada
    /**
     * @return {?}
     */
    get _isTada() { return this.animation === PrettyCheckboxAnimation.Tada; }
    // Rotate
    /**
     * @return {?}
     */
    get _isRotate() { return this.animation === PrettyCheckboxAnimation.Rotate; }
    // Pulse
    /**
     * @return {?}
     */
    get _isPulse() { return this.animation === PrettyCheckboxAnimation.Pulse; }
    /**
     * @return {?}
     */
    get _isToggle() { return this._toggleComp.length === 2 || this._toggleWillChangeComp.length === 2; }
    // DEFAULT
    /**
     * @return {?}
     */
    get _isDefault() { return !this.isSwitch && !this._iconElem && !this._svgElem && !this._imageElem; }
    /**
     * @return {?}
     */
    get _isHover() { return this._hoverComp || this._hoverWillChangeDir; }
    // ---------- METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    _onChange(event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.change.emit({ value, checked, event });
        if (this.radioGroup) {
            this.radioGroup._emitChange({ value, checked, event });
        }
    }
}
NgxPrettyRadioWillChangeComponent.ɵfac = function NgxPrettyRadioWillChangeComponent_Factory(t) { return new (t || NgxPrettyRadioWillChangeComponent)(ɵngcc0.ɵɵdirectiveInject(NgxPrettyRadioGroupDirective, 8)); };
NgxPrettyRadioWillChangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyRadioWillChangeComponent, selectors: [["ngx-pretty-radio", "will-change", ""], ["p-radio", "will-change", ""]], contentQueries: function NgxPrettyRadioWillChangeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIconDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettySvgDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyImageDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverWillChangeComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleComponent, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleWillChangeComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._iconElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._svgElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._imageElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverWillChangeDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverComp = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleComp = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleWillChangeComp = _t);
    } }, viewQuery: function NgxPrettyRadioWillChangeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c3, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElem = _t.first);
    } }, hostAttrs: [1, "pretty"], hostVars: 42, hostBindings: function NgxPrettyRadioWillChangeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("p-switch", ctx.isSwitch)("p-locked", ctx.lock)("p-bigger", ctx.bigger)("p-has-focus", ctx.enableFocus)("p-plain", ctx.plain)("p-fill", ctx._isFill)("p-slim", ctx._isSlim)("p-thick", ctx._isThick)("p-curve", ctx._isCurve)("p-round", ctx._isRound)("p-smooth", ctx._isSmooth)("p-jelly", ctx._isJelly)("p-tada", ctx._isTada)("p-rotate", ctx._isRotate)("p-pulse", ctx._isPulse)("p-toggle", ctx._isToggle)("p-default", ctx._isDefault)("p-has-hover", ctx._isHover)("p-icon", ctx._iconElem)("p-svg", ctx._svgElem)("p-image", ctx._imageElem);
    } }, inputs: { outline: "outline", checked: "checked", disabled: "disabled", isSwitch: "isSwitch", lock: "lock", bigger: "bigger", enableFocus: "enableFocus", plain: "plain", stroke: "stroke", shape: "shape", animation: "animation", color: "color", value: "value", name: "name" }, outputs: { change: "change" }, exportAs: ["ngxPrettyRadio"], attrs: _c2, ngContentSelectors: _c6, decls: 4, vars: 5, consts: [["type", "radio", 3, "name", "value", "checked", "disabled", "change"], ["inputElem", ""], ["class", "state", 3, "ngClass", 4, "ngIf"], [1, "state", 3, "ngClass"]], template: function NgxPrettyRadioWillChangeComponent_Template(rf, ctx) { if (rf & 1) {
        const _r2 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵprojectionDef(_c5);
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function NgxPrettyRadioWillChangeComponent_Template_input_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const _r0 = ɵngcc0.ɵɵreference(1); return ctx._onChange($event, _r0.checked, _r0.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NgxPrettyRadioWillChangeComponent_div_2_Template, 4, 3, "div", 2);
        ɵngcc0.ɵɵprojection(3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("name", ctx.name || ctx.radioGroupName)("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx._isToggle);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
NgxPrettyRadioWillChangeComponent.ctorParameters = () => [
    { type: NgxPrettyRadioGroupDirective, decorators: [{ type: Optional }] }
];
NgxPrettyRadioWillChangeComponent.propDecorators = {
    _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
    change: [{ type: Output }],
    stroke: [{ type: Input }],
    shape: [{ type: Input }],
    animation: [{ type: Input }],
    color: [{ type: Input }],
    outline: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    isSwitch: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}switch`,] }, { type: Input }],
    lock: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}locked`,] }, { type: Input }],
    bigger: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}bigger`,] }, { type: Input }],
    enableFocus: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}has-focus`,] }, { type: Input }],
    plain: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}plain`,] }, { type: Input }],
    _isFill: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Fill}`,] }],
    _isSlim: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Slim}`,] }],
    _isThick: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Thick}`,] }],
    _isCurve: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxShape.Curve}`,] }],
    _isRound: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxShape.Round}`,] }],
    _isSmooth: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Smooth}`,] }],
    _isJelly: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Jelly}`,] }],
    _isTada: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Tada}`,] }],
    _isRotate: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Rotate}`,] }],
    _isPulse: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Pulse}`,] }],
    _toggleComp: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
    _toggleWillChangeComp: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }],
    _isToggle: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}toggle`,] }],
    _isDefault: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}default`,] }],
    _iconElem: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}icon`,] }, { type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
    _svgElem: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}svg`,] }, { type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
    _imageElem: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}image`,] }, { type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
    _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
    _hoverComp: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
    _isHover: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}has-hover`,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyRadioWillChangeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-pretty-radio[will-change], p-radio[will-change]',
                template: `
    <input
      #inputElem
      type="radio"
      [name]="name || radioGroupName"
      [value]="value"
      [checked]="checked"
      [disabled]="disabled"
      (change)="_onChange($event, inputElem.checked, inputElem.value)"/>

    <div *ngIf="!_isToggle" class="state"
        [ngClass]="[ color ? _prefix + color + (outline ? _outlinePrefix : '') : '' ]">

        <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
        <label><ng-content></ng-content></label>
    </div>

    <ng-content select="ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle"></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': DEFAULT_PRETTY_CLASS_NAME
                },
                exportAs: 'ngxPrettyRadio'
            }]
    }], function () { return [{ type: NgxPrettyRadioGroupDirective, decorators: [{
                type: Optional
            }] }]; }, { change: [{
            type: Output
        }], outline: [{
            type: Input
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], isSwitch: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}switch`]
        }, {
            type: Input
        }], lock: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}locked`]
        }, {
            type: Input
        }], bigger: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}bigger`]
        }, {
            type: Input
        }], enableFocus: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}has-focus`]
        }, {
            type: Input
        }], plain: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}plain`]
        }, {
            type: Input
        }], _isFill: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Fill}`]
        }], _isSlim: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Slim}`]
        }], _isThick: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Thick}`]
        }], _isCurve: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxShape.Curve}`]
        }], _isRound: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxShape.Round}`]
        }], _isSmooth: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Smooth}`]
        }], _isJelly: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Jelly}`]
        }], _isTada: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Tada}`]
        }], _isRotate: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Rotate}`]
        }], _isPulse: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Pulse}`]
        }], _isToggle: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}toggle`]
        }], _isDefault: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}default`]
        }], _isHover: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}has-hover`]
        }], _inputElem: [{
            type: ViewChild,
            args: ['inputElem', { static: true }]
        }], stroke: [{
            type: Input
        }], shape: [{
            type: Input
        }], animation: [{
            type: Input
        }], color: [{
            type: Input
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }], _toggleComp: [{
            type: ContentChildren,
            args: [NgxPrettyToggleComponent]
        }], _toggleWillChangeComp: [{
            type: ContentChildren,
            args: [NgxPrettyToggleWillChangeComponent]
        }], _iconElem: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}icon`]
        }, {
            type: ContentChild,
            args: [NgxPrettyIconDirective, { static: false }]
        }], _svgElem: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}svg`]
        }, {
            type: ContentChild,
            args: [NgxPrettySvgDirective, { static: false }]
        }], _imageElem: [{
            type: HostBinding,
            args: [`class.${DEFAULT_PREFIX}image`]
        }, {
            type: ContentChild,
            args: [NgxPrettyImageDirective, { static: false }]
        }], _hoverWillChangeDir: [{
            type: ContentChild,
            args: [NgxPrettyHoverWillChangeComponent, { static: false }]
        }], _hoverComp: [{
            type: ContentChild,
            args: [NgxPrettyHoverComponent, { static: false }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DECLARATIONS = [
    NgxPrettyCheckboxComponent,
    NgxPrettyCheckboxWillChangeComponent,
    NgxPrettyIconDirective,
    NgxPrettySvgDirective,
    NgxPrettyImageDirective,
    NgxPrettyToggleComponent,
    NgxPrettyToggleWillChangeComponent,
    NgxPrettyHoverComponent,
    NgxPrettyHoverWillChangeComponent,
    NgxPrettyIndeterminateComponent,
    NgxPrettyIndeterminateWillChangeComponent,
    NgxPrettyRadioGroupDirective,
    NgxPrettyRadioComponent,
    NgxPrettyRadioWillChangeComponent
];
class NgxPrettyCheckboxModule {
}
NgxPrettyCheckboxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxPrettyCheckboxModule });
NgxPrettyCheckboxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxPrettyCheckboxModule_Factory(t) { return new (t || NgxPrettyCheckboxModule)(); }, imports: [[
            CommonModule,
            FormsModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxPrettyCheckboxModule, { declarations: function () { return [NgxPrettyCheckboxComponent,
        NgxPrettyCheckboxWillChangeComponent,
        NgxPrettyIconDirective,
        NgxPrettySvgDirective,
        NgxPrettyImageDirective,
        NgxPrettyToggleComponent,
        NgxPrettyToggleWillChangeComponent,
        NgxPrettyHoverComponent,
        NgxPrettyHoverWillChangeComponent,
        NgxPrettyIndeterminateComponent,
        NgxPrettyIndeterminateWillChangeComponent,
        NgxPrettyRadioGroupDirective,
        NgxPrettyRadioComponent,
        NgxPrettyRadioWillChangeComponent]; }, imports: function () { return [CommonModule,
        FormsModule]; }, exports: function () { return [NgxPrettyCheckboxComponent,
        NgxPrettyCheckboxWillChangeComponent,
        NgxPrettyIconDirective,
        NgxPrettySvgDirective,
        NgxPrettyImageDirective,
        NgxPrettyToggleComponent,
        NgxPrettyToggleWillChangeComponent,
        NgxPrettyHoverComponent,
        NgxPrettyHoverWillChangeComponent,
        NgxPrettyIndeterminateComponent,
        NgxPrettyIndeterminateWillChangeComponent,
        NgxPrettyRadioGroupDirective,
        NgxPrettyRadioComponent,
        NgxPrettyRadioWillChangeComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPrettyCheckboxModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule
                ],
                declarations: [DECLARATIONS],
                exports: [DECLARATIONS]
            }]
    }], null, null); })();

export { NgxPrettyCheckboxComponent, NgxPrettyCheckboxModule, NgxPrettyCheckboxWillChangeComponent, NgxPrettyHoverComponent, NgxPrettyHoverWillChangeComponent, NgxPrettyIconDirective, NgxPrettyImageDirective, NgxPrettyIndeterminateComponent, NgxPrettyIndeterminateWillChangeComponent, NgxPrettyRadioComponent, NgxPrettyRadioGroupDirective, NgxPrettyRadioWillChangeComponent, NgxPrettySvgDirective, NgxPrettyToggleComponent, NgxPrettyToggleWillChangeComponent, PrettyCheckBoxToggleType, PrettyCheckboxAnimation, PrettyCheckboxColor, PrettyCheckboxShape, PrettyCheckboxStroke, DEFAULT_PRETTY_CLASS_NAME as ɵa, DEFAULT_PREFIX as ɵb, NgxPrettyRadioService as ɵc };

//# sourceMappingURL=ngx-pretty-checkbox.js.map